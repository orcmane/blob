if (context.Request.Method == HttpMethods.Post || context.Request.Method == HttpMethods.Put)
        {
            if (context.Request.ContentType?.Contains("application/json") == true)
            {
                // Enable reading the request body multiple times
                context.Request.EnableBuffering();

                using var reader = new StreamReader(context.Request.Body, leaveOpen: true);
                string body = await reader.ReadToEndAsync();
                context.Request.Body.Position = 0;

                // Parse body to get username
                var json = System.Text.Json.JsonDocument.Parse(body);
                if (json.RootElement.TryGetProperty("username", out var usernameElement))
                {
                    var usernameInBody = usernameElement.GetString();

                    // Get username from JWT (usually in "sub" or "username" claim)
                    var usernameFromToken = context.User?.FindFirst("sub")?.Value 
                                            ?? context.User?.FindFirst("username")?.Value;

                    if (usernameInBody != usernameFromToken)
                    {
                        context.Response.StatusCode = StatusCodes.Status401Unauthorized;
                        await context.Response.WriteAsync("Username in token does not match body.");
                        return;
                    }
                }
            }
        }



using Microsoft.AspNetCore.Authentication.JwtBearer;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.IdentityModel.Tokens;
using System;

public static class JwtSecurityConfiguration
{
    public static void ConfigureJwtBearer(JwtBearerOptions options, IConfiguration configuration)
    {
        options.TokenValidationParameters.RequireSignedTokens = true;
        options.TokenValidationParameters.RequireExpirationTime = true;
        options.TokenValidationParameters.ValidateIssuerSigningKey = true;

        // Restrict to your Azure AD tenant
        options.TokenValidationParameters.ValidIssuers = new[]
        {
            $"https://login.microsoftonline.com/{configuration["AzureAd:TenantId"]}/v2.0"
        };

        // Restrict to your application's audience
        options.TokenValidationParameters.ValidAudiences = new[]
        {
            configuration["AzureAd:ClientId"],
            $"api://{configuration["AzureAd:ClientId"]}"
        };

        // Block dangerous JWT headers flagged by Fortify
        options.TokenValidationParameters.HeaderValidator = (header, _) =>
        {
            if (header.ContainsKey("jwk") ||
                header.ContainsKey("jku") ||
                header.ContainsKey("x5u") ||
                header.ContainsKey("x5c"))
            {
                throw new SecurityTokenValidationException(
                    "Token contains potentially unsafe header claims."
                );
            }

            return header;
        };
    }
}

public static class ServiceCollectionExtensions
{
    public static IServiceCollection AddAuthenticationServices(this IServiceCollection services, IConfiguration configuration)
    {
        // Add MS Identity Web API authentication
        services.AddMicrosoftIdentityWebApiAuthentication(configuration);

        // Enhance security with Fortify-approved validations
        services.Configure<JwtBearerOptions>(JwtBearerDefaults.AuthenticationScheme,
            options => JwtSecurityConfiguration.ConfigureJwtBearer(options, configuration));

        return services;
    }
}
 Concurrent Requests

Hi Team,

During the recent pentest, one issue was reported: “Lack of rate limiting.”
Based on your test results, this issue appeared when the system was tested with 2,000 simultaneous requests.

For context, we had configured the rate-limiting threshold in our application to 2,000 requests.
In the previous pentest, the test was performed with over 5,000 simultaneous requests, and we received the same issue. After that, we implemented and enforced rate limiting in the code with the threshold set to 2,000 requests.

Since the latest pentest also used exactly 2,000 requests, the test hit the threshold limit itself, which caused the issue to appear again. The system is working as designed, but the test parameters matched the configured threshold.

To properly validate the effectiveness of the rate limiting, we kindly request a retest with more than 2,000 simultaneous requests (e.g., 3,000–5,000 or higher). This will confirm that the rate limiter is functioning correctly beyond the configured limit.

Please let us know if you need any additional details from our side.